% !TeX spellcheck = es_ES
\documentclass[titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[letterpaper, margin=2.5cm]{geometry}
\usepackage[spanish]{babel}
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{RGB}{253,151,31}
\definecolor{deepred}{RGB}{249,38,114}

\lstset{frame=tb,
    language=Python,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    numbers=left,
    stepnumber=1,
    basicstyle={\small\ttfamily},
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=2,
    morekeywords={self, append},
    emph={Transicion,__init__, True, False},
    emphstyle=\em\color{deepred}
}

\title{Reporte: Práctica 1}
\author{Barrera Pérez Carlos Tonatihu \\ Profesor: Saucedo Delgado Rafael Norman \\ Compiladores \\ Grupo: 3CM6 }

\begin{document}
	\maketitle
	\tableofcontents
	
	\section{Introducción}
	Los autómatas finitos no determinista y determinista nos permiten identificar si una cadena (secuencia de símbolos) 
	pertenece a un determinado lenguaje regular. Las principales diferencias entre estos dos tipos de autómatas son las siguientes.
	
	\begin{itemize}
		\item Autómata finito no determinista: Un mismo símbolo puede conducir a diferentes estados desde un mismo estado, 
		además, la cadena vacía es valida.
		\item Autómata finito determinista: El autómata tiene por cada estado y por cada símbolo sólo una transición hacia otro estado.
	\end{itemize}

	La descripción formal de un autómata determinista $A$ es la siguientes.
	\[ A = (Q, \Sigma , \delta, q_{0}, F) \]
	Donde:
	
	\begin{itemize}
		\item $Q$ es un conjunto de estados finitos.
		\item $\Sigma$ es un conjunto finito de símbolos de entrada.
		\item $\delta$ es una función de transición que toma como argumentos un estado y un símbolo y retorna un nuevo estado. 
		En un autómata no determinista la función devuelve un conjunto de estados que pertenecen a $Q$.
		\item $q_{0}$ es un estado inicial que pertenece al conjunto de estados finitos $Q$.
		\item $F$ es un conjunto de estados finales que pertenecen al conjunto $Q$.

	\end{itemize}

	Todas estas características fueron importantes en esta práctica ya que al tenerlas en consideración se pudieron 
	modelar los dos tipos de autómatas mediante el uso de programación orientada a objetos en este caso se utilizo Python. 
	Y con ello poder representar cualquier autómata finito a partir de los elementos que lo componen.
	
	\section{Desarrollo}
	En esta práctica se uso el paradigma orientado a objetos para poder modelar cualquier autómata finito determinista 
	o no determinista con base a sus componentes y con esto poder evaluar cualquier cadena y poder determinar 
	si pertenece a algún determinado lenguaje. Se programaron 3 clases, una para el autómata determinista, otra para el no determinista y una clase extra para poder
	representar las transiciones que se realizan de una manera más facil.
	
	Primero tenemos el codigo de la clase Transicion.
	\begin{lstlisting}
	class Transicion:
	  def __init__(self, actual, siguiente, caracter):
	    self.actual = actual
	    self.siguiente = siguiente
	    self.caracter = caracter
	    
	  # Metodo para poder imprimir de forma legible una instancia de esta clase
	  def __str__(self):
	    return '{}->{}: {}'.format(self.actual, self.siguiente, self.caracter)
	\end{lstlisting}
	Como se puede observar en el codigo nuestra transicion consiste de un estado actual, uno siguiente y un simbolo que realiza esa transición.
	Esto nos ayudara a modelar las clases de los automatas de una manera más clara.
	
	El código de la clase AFN fue:
	\begin{lstlisting}
	 class AFN:
    def __init__(self):
        self.alfabeto = set()
        self.estados_finales = set()
        self.estado_inicial = 0
        self.estados_actuales = list()
        self.transiciones = list()
        self.estados = set()
        self.estado_error = -1

    def agregar_transicion(self, actual, siguiente, caracter):
        self.transiciones.append(Transicion(actual, siguiente, caracter))

    def agregar_finales(self, estados):
        self.estados_finales = estados

    def agregar_alfabeto(self, alfabeto):
        self.alfabeto = alfabeto
        self.alfabeto.add('e')

    def agregar_inicial(self, estado):
        self.estado_inicial = estado

    def agregar_estado(self, estado):
        if estado in self.estados:
            print("Estado repetido")
        else:
            self.estados.add(estado)

    def evaluar_cadena(self, cadena):
        self.estados_actuales = self.estados_epsilon(self.estado_inicial)
        for caracter in cadena:
            if caracter not in self.alfabeto:
                return False
            siguientes_estados = self.obtener_siguientes(caracter)
            self.estados_actuales = []
            for e in siguientes_estados:
                self.estados_actuales.extend(self.estados_epsilon(e))

        for estado in self.estados_actuales:
            if estado in self.estados_finales:
                return True
        return False

    def obtener_siguientes(self, caracter):
        siguientes = list()
        for estado in self.estados_actuales:
            for transicion in self.transiciones:
                if estado == transicion.actual and transicion.caracter == caracter:
                    siguientes.append(transicion.siguiente)
        return siguientes

    def estados_epsilon(self, estados):
        epsilon = list()
        epsilon.append(estados)
        for estado in epsilon:
            for t in self.transiciones:
                if t.caracter == 'e' and t.actual == estado and (t.siguiente not in epsilon):
                    epsilon.append(t.siguiente)
        return epsilon
	\end{lstlisting}

	
	El código de la clase AFD hereda muchas propiedades y métodos de la clase AFN modificando el método que se encarga de la evaluación de la cadena.
	\begin{lstlisting}
class AFD(AFN):
  def agregar_alfabeto(self, alfabeto):
    self.alfabeto = alfabeto

  def evaluar_cadena(self, cadena):
    self.estados_actuales.append(self.estado_inicial)
    continuar = True
    for caracter in cadena:
      if caracter not in self.alfabeto:
        return False
      for transicion in self.transiciones:
        if transicion.actual == self.estados_actuales[0]:
          if transicion.caracter == caracter:
            self.estados_actuales[0] = transicion.siguiente
            continuar = True
            break
        else:
          continuar = False
      if not continuar:
       self.estados_actuales[0] = self.estado_error

    return self.estados_actuales[0] in self.estados_finales
	\end{lstlisting}

	\section{Resultados}
	hola
	\section{Conclusiones}
	Fue indispensable conocer los componentes de este tipo de autómatas ademas de saber el como trabajan 
	ya que sin este conocimiento seria imposible el poder modelarlos en una clase. La parte difícil de esta 
	práctica fue el AFN ya que al poder ir a varios estados desde una mismo con el mismo símbolo por lo que 
	aumenta su complejidad al aumentar el numero de caminos que se pueden tomar. 
	Así que el revisar libros y ejercicios relacionados con este tema fue importante para poder solucionar este problema.
	\section{Referencias}
\end{document}